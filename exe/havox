#!/usr/bin/env ruby

require 'havox'
require 'optparse'
require 'ostruct'
require_relative '../lib/havox/app/api'

# Defines command options and parameters.
args = OpenStruct.new
OptionParser.new do |opt|
  opt.separator ''
  opt.separator <<-DESCRIPTION
  Havox is a rule generator for Autonomous Systems supported by OpenFlow switches.
  Based on a directives file written in its own DSL and a graph topology file, Havox
  generates a set of OpenFlow rules to be installed in the underlying switches. Just
  run the following command to start the Havox API web server:

  havox

  This will run the server on port 4567. It listens for HTTP requests to the /rules
  route, POST method. The request should contain the directives file, the topology
  file and a set of configuration parameters that define how the rules should be
  formatted.

  An alternative way to run Havox is by calling its rules-only mode (prints the rules
  to the STDOUT) or using the Trema controller (yet experimental). See the options below.
  DESCRIPTION
  opt.separator ''

  opt.on('-c', '--trema-topo CONF', 'Trema topology configuration file') { |o| args.trema_topology = o }
  opt.on('-t', '--merlin-topo TOPO', 'Merlin topology file') { |o| args.merlin_topology = o }
  opt.on('-p', '--merlin-policy POLICY', 'Merlin policy file') { |o| args.merlin_policy = o }
  opt.on('-d', '--directives DIRECTIVES_FILE', 'Havox directives file') { |o| args.havox_directives = o }
  opt.on('-s', '--syntax trema,ovs,routeflow', [:trema, :ovs, :routeflow], 'Output syntax for generated rules (default: trema)') { |o| args.syntax = o }
  opt.on('-f', '--[no-]force', 'Forces Havox to ignore field conflicts in rules generated by Merlin') { |o| args.force = o }
  opt.on('-b', '--[no-]basic-policies', 'Automatically appends policies for basic protocols in the policies file') { |o| args.basic = o }
  opt.on('-x', '--[no-]expand', 'Expands rules from VLAN-based to full predicates') { |o| args.expand = o }
  opt.on('-o', '--[no-]output', 'Switches all occurrences of Enqueue action to Output action') { |o| args.output = o }
  opt.on('--rules-only', 'Tells Havox to just output rules without loading anything') { |o| args.rules_only = o }
  opt.on('--trema', 'Tells Havox to load Trema environment') { |o| args.trema = o }
end.parse!

# Sets all required environment variables to be read in the controller.
def set_environment_vars(args)
  ENV['HAVOX_FORCE'] = args.force.to_s
  ENV['HAVOX_BASIC'] = args.basic.to_s
  ENV['HAVOX_EXPAND'] = args.expand.to_s
  ENV['HAVOX_OUTPUT'] = args.output.to_s
  ENV['HAVOX_SYNTAX'] = args.syntax.to_s
  ENV['HAVOX_MERLIN_TOPOLOGY'] = args.merlin_topology
  ENV['HAVOX_MERLIN_POLICY'] = args.merlin_policy
end

# Defines the Trema execution method.
def start_trema!(args)
  puts 'Loading Havox with Trema...'
  cmd = 'trema run lib/trema/controllers/main_controller.rb' \
  " -c #{args.trema_topology}"
  system(cmd)
rescue Interrupt
  puts 'Closing.'
end

# Checks arguments for rules generation.
def files_ok?(args)
  !(args.havox_directives.nil? && args.merlin_policy.nil?) &&
    !args.merlin_topology.nil?
end

# Checks arguments for Trema initialization.
def can_start_trema?(args)
  !args.trema_topology.nil? && files_ok?(args)
end

# Sets environment variables and starts Havox.
def set_env_and_start_trema!(args)
  if can_start_trema?(args)
    set_environment_vars(args)
    start_trema!(args)
  end
end

# Transcompiles Havox directives to Merlin blocks and returns the resulting Merlin file.
def transcompile_to_merlin(args)
  mln_filename = "./#{File.basename(args.havox_directives, '.hvx')}.mln"
  eval File.read(args.havox_directives)
  mln_blocks = Havox::Network.transcompile(args)
  File.open(mln_filename, 'w') { |f| f.write(mln_blocks.join("\n")) }
  mln_filename
end

# Calls the rules generation and outputs the rules.
def output_rules!(args)
  if files_ok?(args)
    args.merlin_policy = transcompile_to_merlin(args) unless args.havox_directives.nil?
    puts Havox::Policy.new(args.to_h).to_json
  end
end

# After everything is defined, main execution flux starts here.
if args.rules_only
  output_rules!(args)
elsif args.trema
  set_env_and_start_trema!(args)
else
  Havox::API.run!
end
