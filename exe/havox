#!/usr/bin/env ruby

require 'havox'
require 'optparse'
require 'ostruct'

# Defines command options and parameters.
args = OpenStruct.new
OptionParser.new do |opt|
  opt.on('-c', '--trema-topo CONF', 'Trema topology configuration file') { |o| args.trema_topology = o }
  opt.on('-t', '--merlin-topo TOPO', 'Merlin topology file') { |o| args.merlin_topology = o }
  opt.on('-p', '--merlin-policy POLICY', 'Merlin policy file') { |o| args.merlin_policy = o }
  opt.on('-s', '--syntax trema,ovs,routeflow', [:trema, :ovs, :routeflow], 'Output syntax for generated rules (default: trema)') { |o| args.syntax = o }
  opt.on('-f', '--[no-]force', 'Forces Havox to ignore field conflicts in rules generated by Merlin') { |o| args.force = o }
  opt.on('-b', '--[no-]basic-policies', 'Automatically appends policies for basic protocols in the policies file') { |o| args.basic = o }
  opt.on('-x', '--[no-]expand', 'Expands rules from VLAN-based to full predicates') { |o| args.expand = o }
  opt.on('-o', '--[no-]output', 'Switches all occurrences of Enqueue action to Output action') { |o| args.output = o }
  opt.on('--rules-only', 'Tells Havox to just output rules without loading anything') { |o| args.rules_only = o }
  opt.on('--trema', 'Tells Havox to load Trema environment') { |o| args.trema = o }
end.parse!

# Sets all required environment variables to be read in the controller.
def set_environment_vars(args)
  ENV['HAVOX_FORCE'] = args.force.to_s
  ENV['HAVOX_BASIC'] = args.basic.to_s
  ENV['HAVOX_EXPAND'] = args.expand.to_s
  ENV['HAVOX_OUTPUT'] = args.output.to_s
  ENV['HAVOX_SYNTAX'] = args.syntax.to_s
  ENV['HAVOX_MERLIN_TOPOLOGY'] = args.merlin_topology
  ENV['HAVOX_MERLIN_POLICY'] = args.merlin_policy
end

# Defines the main execution method.
def start_trema!(args)
  puts 'Loading Havox with Trema...'
  cmd = 'trema run lib/trema/controllers/main_controller.rb' \
  " -c #{args.trema_topology}"
  system(cmd)
rescue Interrupt
  puts 'Closing.'
end

# Checks arguments for rules generation.
def can_generate_rules?(args)
  !(args.merlin_topology.nil? || args.merlin_policy.nil?)
end

# Checks arguments for Trema initialization.
def can_start_trema?(args)
  !args.trema_topology.nil? && can_generate_rules?(args)
end

# Sets environment variables and starts Havox.
def set_env_and_start_trema!(args)
  if can_start_trema?(args)
    set_environment_vars(args)
    start_trema!(args)
  end
end

# Calls the rules generation and outputs the rules.
def output_rules!(args)
  if can_generate_rules?(args)
    puts Havox::Policy.new(args.to_h).to_json
  end
end

# After everything is defined, main execution flux starts here.
if args.rules_only
  output_rules!(args)
elsif args.trema
  set_env_and_start_trema!(args)
else
  puts 'API in development.'
end
